<p><i id="p_0" class="pid"></i>Reach has a few sub-commands, each with their own options.<a href="#p_0" class="pid">0</a></p>
<p><i id="p_1" class="pid"></i>However, all commands support the following options:<a href="#p_1" class="pid">1</a></p>
<ul>
  <li><i id="p_2" class="pid"></i>The environment variable <code>REACH_VERSION</code> signifies what version of Reach to use.<a href="#p_2" class="pid">2</a></li>
</ul>
<p><i id="p_3" class="pid"></i>Although normally expressed in a <a href="/guide/versions/#guide-versions">semantic versioning</a>-friendly format, e.g. <code>v0.1</code> or <code>v0.1.6</code>, <code>REACH_VERSION</code> also supports:<a href="#p_3" class="pid">3</a></p>
<ul>
  <li><i id="p_4" class="pid"></i>Hashes such as <a href="https://hub.docker.com/layers/reachsh/reach/639fa565/images/sha256-e72fbb183e559a6f531302843c1d4debb499c9286e0ca4839ae66023c7ba2296?context=explore">639fa565</a>.<a href="#p_4" class="pid">4</a></li>
</ul>
<p><i id="p_5" class="pid"></i>Valid hashes may be obtained by running:<a href="#p_5" class="pid">5</a></p>
<pre class="snippet numbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach hashes
reach: 8150e7e4
reach-cli: 8150e7e4
react-runner: fb449c94
rpc-server: fb449c94
runner: fb449c94
devnet-algo: fb449c94
devnet-cfx fb449c94
devnet-eth: fb449c94" href="#"></a></div><ol class="snippet"><li value="1">$ reach hashes</li><li value="2">reach: 8150e7e4</li><li value="3">reach-cli: 8150e7e4</li><li value="4">react-runner: fb449c94</li><li value="5">rpc-server: fb449c94</li><li value="6">runner: fb449c94</li><li value="7">devnet-algo: fb449c94</li><li value="8">devnet-cfx fb449c94</li><li value="9">devnet-eth: fb449c94</li></ol></pre>
<ul>
  <li><i id="p_6" class="pid"></i>Date-stamps such as <a href="https://hub.docker.com/layers/reachsh/reach/2021-11-04/images/sha256-e72fbb183e559a6f531302843c1d4debb499c9286e0ca4839ae66023c7ba2296?context=explore">2021-11-04</a>.<a href="#p_6" class="pid">6</a></li>
</ul>
<p><i id="p_7" class="pid"></i>Valid date-stamps may be obtained by browsing Reach's public Docker image registry on <a href="https://hub.docker.com/r/reachsh/reach/tags">DockerHub</a>.<a href="#p_7" class="pid">7</a></p>
<p><i id="p_8" class="pid"></i>Tip: try entering your desired year in the filter box to skip other tag types.<a href="#p_8" class="pid">8</a></p>
<ul>
  <li><i id="p_9" class="pid"></i>The identifer "<code>stable</code>".<a href="#p_9" class="pid">9</a></li>
</ul>
<p><i id="p_10" class="pid"></i>Reach will interpret this to mean the most recent stable <a href="/guide/versions/#guide-versions">major</a> version.<a href="#p_10" class="pid">10</a></p>
<p>
  <i id="p_11" class="pid"></i>When using the semantic versioning form of <code>REACH_VERSION</code> the preceding <code>v</code> character is optional.
  In other words, <code>v0.1.6</code> is equivalent to <code>0.1.6</code>.<a href="#p_11" class="pid">11</a>
</p>
<h2 id="ref-usage-compile" class="refHeader"><code>reach compile</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-compile"><span class="icon icon-link"></span></a></h2>
<p><i id="p_12" class="pid"></i>You compile your Reach code by executing<a href="#p_12" class="pid">12</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach compile SOURCE EXPORT ..." href="#"></a></div><ol class="snippet"><li value="1">$ reach compile SOURCE EXPORT ...</li></ol></pre>
<p>
  <i id="p_13" class="pid"></i>where <code>SOURCE</code> is your source file,
  and each <code>EXPORT</code> is an exported Reach.App.<a href="#p_13" class="pid">13</a>
</p>
<p><i id="p_14" class="pid"></i>If no <code>SOURCE</code> is provided, then <code>index.rsh</code> is used.<a href="#p_14" class="pid">14</a></p>
<p>
  <i id="p_15" class="pid"></i>If no <code>EXPORT</code> is provided, then all the exported Reach.Apps will be compiled. If there are no
  Reach.Apps exported, then the program will be compiled as a library, where its exports are available
  to other Reach programs and frontends. The output name of a library is the same as if it exported a Reach.App
  named <code>default</code>.<a href="#p_15" class="pid">15</a>
</p>
<p><i id="p_16" class="pid"></i><code>reach compile</code> supports the following options:<a href="#p_16" class="pid">16</a></p>
<ul>
  <li><i id="p_17" class="pid"></i><code>-o</code>/<code>--output</code> <code>OUTPUT</code> --- Writes compiler output files to <code>OUTPUT</code>, which defaults to a directory named <code>build</code> in the same directory as <code>SOURCE</code>.<a href="#p_17" class="pid">17</a></li>
  <li><i id="p_18" class="pid"></i><code>--intermediate-files</code> --- Write intermediate files, which may be interesting for debugging compilation failures or using in other contexts.<a href="#p_18" class="pid">18</a></li>
  <li><i id="p_19" class="pid"></i><code>--install-pkgs</code> --- Allows Reach to fetch remote package imports and stop after doing so.<a href="#p_19" class="pid">19</a></li>
</ul>
<p><i id="p_20" class="pid"></i>Reach will fail with an error message if package imports have not yet been fetched and this flag is not activated.<a href="#p_20" class="pid">20</a></p>
<p>
  <i id="p_21" class="pid"></i>Using this flag will create a <code>.reach</code> directory for your project.
  This directory stores your project's <span class="term" id="term_lockfile">lockfile</span>, which is how Reach pins remote packages to specific versions.
  It is recommended that you commit the <code>.reach</code> directory to source control.
  Deleting this directory is also safe; it can easily be rebuilt by using the <code>--install-pkgs</code> flag again; in fact, this is the best way to upgrade your packages.<a href="#p_21" class="pid">21</a>
</p>
<ul>
  <li>
    <i id="p_22" class="pid"></i><code>--stop-after-eval</code> --- Stops the compilation process before verification and producing output files.
    This might be useful for performing syntax and type checking quickly.<a href="#p_22" class="pid">22</a>
  </li>
  <li>
    <i id="p_23" class="pid"></i><code>--verify-timeout</code> <code>TIMEOUT-MS</code> --- Sets the timeout of individual verification theorems, in milliseconds.
    The default value is 2 minutes.<a href="#p_23" class="pid">23</a>
  </li>
  <li>
    <i id="p_24" class="pid"></i>The environment variable <code>REACH_DEBUG</code>, if set to any non-empty value, enables debug messages from the Reach compiler, which will appear in the console.
    This debug information includes: the estimated cost of the contract on Algorand.<a href="#p_24" class="pid">24</a>
  </li>
</ul>
<h2 id="ref-usage-init" class="refHeader"><code>reach init</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-init"><span class="icon icon-link"></span></a></h2>
<p><i id="p_25" class="pid"></i>You can create template <code>index.rsh</code> and <code>index.mjs</code> files for a simple Reach app by running<a href="#p_25" class="pid">25</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach init" href="#"></a></div><ol class="snippet"><li value="1">$ reach init</li></ol></pre>
<h2 id="ref-usage-run" class="refHeader"><code>reach run</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-run"><span class="icon icon-link"></span></a></h2>
<p><i id="p_26" class="pid"></i>You can run a simple Reach application by executing<a href="#p_26" class="pid">26</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach run [APP or DIR] [ARGS]" href="#"></a></div><ol class="snippet"><li value="1">$ reach run [APP or DIR] [ARGS]</li></ol></pre>
<p><i id="p_27" class="pid"></i><code>APP</code> represents a Reach module name without its extension (e.g. "index" by default).<a href="#p_27" class="pid">27</a></p>
<p><i id="p_28" class="pid"></i>If no <code>APP</code> or <code>DIR</code> is provided then <code>index</code> in the current working directory is assumed.<a href="#p_28" class="pid">28</a></p>
<p><i id="p_29" class="pid"></i>If <code>DIR</code> matches an existing, relative subdirectory of the current working directory then <code>DIR/index</code> is used.<a href="#p_29" class="pid">29</a></p>
<p><i id="p_30" class="pid"></i><code>ARGS</code> represents zero or more arguments to be passed into <code>APP</code>'s frontend.<a href="#p_30" class="pid">30</a></p>
<p><i id="p_31" class="pid"></i>This assumes<a href="#p_31" class="pid">31</a></p>
<ul>
  <li><i id="p_32" class="pid"></i>Your Reach program is named <code>APP.rsh</code>.<a href="#p_32" class="pid">32</a></li>
  <li>
    <i id="p_33" class="pid"></i>You are using the JavaScript backend and your frontend is named <code>APP.mjs</code>.
    It also assumes the backend is located at <code>DIR/build/APP.main.mjs</code>, and only depends on the Reach standard library.<a href="#p_33" class="pid">33</a>
  </li>
</ul>
<p><i id="p_34" class="pid"></i>It then<a href="#p_34" class="pid">34</a></p>
<ul>
  <li><i id="p_35" class="pid"></i>Compiles your program with Reach.<a href="#p_35" class="pid">35</a></li>
  <li><i id="p_36" class="pid"></i>Builds a Docker image named <code>reachsh/reach-app-APP:latest</code> that depends on the Reach JavaScript standard library.<a href="#p_36" class="pid">36</a></li>
  <li><i id="p_37" class="pid"></i>Executes a container based upon that image while connected to the network determined by <code>REACH_CONNECTOR_MODE</code>.<a href="#p_37" class="pid">37</a></li>
</ul>
<p><i id="p_38" class="pid"></i><code>reach run</code> supports the following options:<a href="#p_38" class="pid">38</a></p>
<ul>
  <li>
    <p>
      <i id="p_39" class="pid"></i>The mandatory environment variable <code>REACH_CONNECTOR_MODE</code> specifies which context to run in.
      The options are:<a href="#p_39" class="pid">39</a>
    </p>
  </li>
  <li>
    <p><i id="p_40" class="pid"></i><code>ETH-live</code>, which uses a live Ethereum network node, specified by the environment variable <code>ETH_NODE_URI</code>.<a href="#p_40" class="pid">40</a></p>
  </li>
  <li>
    <p><i id="p_41" class="pid"></i><code>ETH-browser</code>, which uses Ethereum via a browser extension, like MetaMask.<a href="#p_41" class="pid">41</a></p>
  </li>
  <li>
    <p><i id="p_42" class="pid"></i><code>ETH-devnet</code>, which uses a Dockerized private Ethereum network.<a href="#p_42" class="pid">42</a></p>
  </li>
  <li>
    <p><i id="p_43" class="pid"></i><code>ALGO-live</code>, which uses a live Algorand network node, specified by the environment variables documented in <a href="/networks/#ref-network-algo">the Algorand connector section</a>.<a href="#p_43" class="pid">43</a></p>
  </li>
  <li>
    <p><i id="p_44" class="pid"></i><code>ALGO-browser</code>, which uses Algorand via an ARC-0011 browser wallet.<a href="#p_44" class="pid">44</a></p>
  </li>
  <li>
    <p><i id="p_45" class="pid"></i><code>ALGO-devnet</code>, which uses a Dockerized private Algorand network.<a href="#p_45" class="pid">45</a></p>
  </li>
  <li>
    <p><i id="p_46" class="pid"></i>The environment variable <code>REACH_DEBUG</code>, if set to any non-empty value, enables debug messages from the Reach standard library, which will appear in the console.<a href="#p_46" class="pid">46</a></p>
  </li>
</ul>
<p>
  <i id="p_47" class="pid"></i><code>reach run</code> can be further specialized via the presence of a <code>Dockerfile</code> and <code>package.json</code> file.
  If either are absent, <code>reach run</code> assumes a default behavior (which may be persisted with <code>reach scaffold</code>).<a href="#p_47" class="pid">47</a>
</p>
<p><i id="p_48" class="pid"></i>The <code>Dockerfile</code> can be modified to introduce new dependencies, services, or filesystem prerequisites into your app's containerized environment, and the <code>package.json</code> file may likewise be extended to include additional libraries or make configuration changes to the resultant Node.js package.<a href="#p_48" class="pid">48</a></p>
<h2 id="ref-usage-down" class="refHeader"><code>reach down</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-down"><span class="icon icon-link"></span></a></h2>
<p><i id="p_49" class="pid"></i>You can halt all Dockerized Reach apps and devnets by running<a href="#p_49" class="pid">49</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach down" href="#"></a></div><ol class="snippet"><li value="1">$ reach down</li></ol></pre>
<h2 id="ref-usage-scaffold" class="refHeader"><code>reach scaffold</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-scaffold"><span class="icon icon-link"></span></a></h2>
<p><i id="p_50" class="pid"></i>You can create templated <code>Dockerfile</code> and <code>package.json</code> files for a simple Reach app by running<a href="#p_50" class="pid">50</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach scaffold" href="#"></a></div><ol class="snippet"><li value="1">$ reach scaffold</li></ol></pre>
<p><i id="p_51" class="pid"></i>The files created are the same as those used temporarily by <code>reach run</code>.<a href="#p_51" class="pid">51</a></p>
<h2 id="ref-usage-react" class="refHeader"><code>reach react</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-react"><span class="icon icon-link"></span></a></h2>
<p><i id="p_52" class="pid"></i>You can run a simple React app by executing<a href="#p_52" class="pid">52</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach react" href="#"></a></div><ol class="snippet"><li value="1">$ reach react</li></ol></pre>
<p><i id="p_53" class="pid"></i>This assumes<a href="#p_53" class="pid">53</a></p>
<ul>
  <li><i id="p_54" class="pid"></i>Your Reach program is named <code>index.rsh</code><a href="#p_54" class="pid">54</a></li>
  <li><i id="p_55" class="pid"></i>Your frontend React program is named <code>index.js</code><a href="#p_55" class="pid">55</a></li>
</ul>
<p><i id="p_56" class="pid"></i>It then<a href="#p_56" class="pid">56</a></p>
<ul>
  <li><i id="p_57" class="pid"></i>Compiles your program with Reach<a href="#p_57" class="pid">57</a></li>
  <li><i id="p_58" class="pid"></i>Runs the appropriate devnet based on <code>REACH_CONNECTOR_MODE</code><a href="#p_58" class="pid">58</a></li>
  <li><i id="p_59" class="pid"></i>Mounts the current directory into <code>/app/src/</code> in the <code>reachsh/react-runner</code> Docker image and runs it.<a href="#p_59" class="pid">59</a></li>
</ul>
<p><i id="p_60" class="pid"></i><code>reach react</code> supports the following options:<a href="#p_60" class="pid">60</a></p>
<ul>
  <li>
    <p>
      <i id="p_61" class="pid"></i>The mandatory environment variable <code>REACH_CONNECTOR_MODE</code> specifies which context to run in.
      The options are:<a href="#p_61" class="pid">61</a>
    </p>
  </li>
  <li>
    <p><i id="p_62" class="pid"></i><code>ETH</code>, which runs a Dockerized private Ethereum network which may be used. The app can use any Ethereum network.<a href="#p_62" class="pid">62</a></p>
  </li>
  <li>
    <p><i id="p_63" class="pid"></i><code>ALGO</code>, which runs a Dockerized private Algorand network which may be used. (Support for using any Algorand network is forthcoming with TEAL 3.)<a href="#p_63" class="pid">63</a></p>
  </li>
  <li>
    <p><i id="p_64" class="pid"></i>The environment variable <code>REACH_DEBUG</code>, if set to any non-empty value, enables debug messages from the Reach standard library, which will appear in the browser console.<a href="#p_64" class="pid">64</a></p>
  </li>
</ul>
<p>
  <i id="p_65" class="pid"></i>When using <span class="snip"><span style="color: #24292E">loadStdlib</span></span> in conjunction with <code>reach react</code>,
  be sure to pass in <span class="snip"><span style="color: #24292E">process.env</span></span> as its argument.
  See <span class="snip"><span style="color: #24292E">loadStdlib</span></span> for details.<a href="#p_65" class="pid">65</a>
</p>
<p>
  <i id="p_66" class="pid"></i><code>reach react</code> does not respect the same scaffolded files as <code>reach run</code>.
  It is just a simplified tool to give you a taste of web programming with reach.
  If you would like access to more customizations on a browser-based project,
  such as custom environment variables,
  custom JavaScript dependencies,
  or using other JavaScript frameworks like Angular,
  we recommend that you simply use <code>reach compile</code>,
  and use your own preferred JavaScript setup for the project.
  The compiled <code>build/index.main.mjs</code> JavaScript file
  and the <code>'@reach-sh/stdlib'</code> JavaScript library
  may be used in any JavaScript project like any other JavaScript file and library, respectively.<a href="#p_66" class="pid">66</a>
</p>
<h2 id="ref-usage-devnet" class="refHeader"><code>reach devnet</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-devnet"><span class="icon icon-link"></span></a></h2>
<p><i id="p_67" class="pid"></i>You can run a private Reach devnet by executing<a href="#p_67" class="pid">67</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach devnet" href="#"></a></div><ol class="snippet"><li value="1">$ reach devnet</li></ol></pre>
<p><i id="p_68" class="pid"></i><code>reach devnet</code> supports the following options:<a href="#p_68" class="pid">68</a></p>
<ul>
  <li>
    <p><i id="p_69" class="pid"></i><code>--await-background</code> --- Run in background and await availability.<a href="#p_69" class="pid">69</a></p>
  </li>
  <li>
    <p>
      <i id="p_70" class="pid"></i>The mandatory environment variable <code>REACH_CONNECTOR_MODE</code> specifies which devnet to run.
      The options are:<a href="#p_70" class="pid">70</a>
    </p>
  </li>
  <li>
    <p><i id="p_71" class="pid"></i><code>ETH</code>, which runs an Ethereum devnet on <code>localhost:8545</code><a href="#p_71" class="pid">71</a></p>
  </li>
  <li>
    <p><i id="p_72" class="pid"></i><code>ALGO</code>, which runs an Algorand devnet on <code>localhost:4180</code> and an Algorand indexer on <code>localhost:8980</code><a href="#p_72" class="pid">72</a></p>
  </li>
  <li>
    <p><i id="p_73" class="pid"></i>The environment variable <code>REACH_DEBUG</code> enables some additional debugging information for the Algorand devnet, which is accessible via <a href="http://localhost:9392">http://localhost:9392</a><a href="#p_73" class="pid">73</a></p>
  </li>
</ul>
<h2 id="ref-usage-rpc-server" class="refHeader"><code>reach rpc-server</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-rpc-server"><span class="icon icon-link"></span></a></h2>
<p><i id="p_74" class="pid"></i>The sub-command<a href="#p_74" class="pid">74</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach rpc-server" href="#"></a></div><ol class="snippet"><li value="1">$ reach rpc-server</li></ol></pre>
<p><i id="p_75" class="pid"></i>starts an instance of the <a href="/rpc/#ref-backends-rpc">Reach RPC Server</a> using all of the same options and defaults as <code>reach run</code>.<a href="#p_75" class="pid">75</a></p>
<p><i id="p_76" class="pid"></i><code>reach rpc-server</code> supports the following options:<a href="#p_76" class="pid">76</a></p>
<ul>
  <li>
    <i id="p_77" class="pid"></i>The environment variable <code>REACH_RPC_KEY</code> is used to determine the RPC server key.
    If not defined, it defaults to <code>opensesame</code>, and a warning will
    appear in the console stating that the development key is being used.<a href="#p_77" class="pid">77</a>
  </li>
</ul>
<p>
  <i id="p_78" class="pid"></i>In a production context this key must be kept secret, and it should be
  randomly generated with a suitably strong method, such as:<a href="#p_78" class="pid">78</a>
</p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ head -c 24 /dev/urandom | base64" href="#"></a></div><ol class="snippet"><li value="1">$ head -c 24 /dev/urandom | base64</li></ol></pre>
<ul>
  <li>
    <i id="p_79" class="pid"></i>The environment variable <code>REACH_RPC_PORT</code> is used to determine which port to bind to.
    It defaults to <code>3000</code>.<a href="#p_79" class="pid">79</a>
  </li>
  <li>
    <i id="p_80" class="pid"></i>The environment variable <code>REACH_RPC_TLS_KEY</code> is used to determine the path to the TLS <code>key</code> file, which must be in the <code>./tls</code> directory.
    It defaults to <code>reach-server.key</code>.<a href="#p_80" class="pid">80</a>
  </li>
  <li>
    <i id="p_81" class="pid"></i>The environment variable <code>REACH_RPC_TLS_CRT</code> is used to determine the path to the TLS <code>crt</code> file, which must be in the <code>./tls</code> directory.
    It defaults to <code>reach-server.crt</code>.<a href="#p_81" class="pid">81</a>
  </li>
  <li>
    <i id="p_82" class="pid"></i>The environment variable <code>REACH_RPC_TLS_PASSPHRASE</code> is used to determine the TLS passphrase.
    It defaults to <code>rpc-demo</code>.<a href="#p_82" class="pid">82</a>
  </li>
</ul>
<h2 id="ref-usage-rpc-run" class="refHeader"><code>reach rpc-run</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-rpc-run"><span class="icon icon-link"></span></a></h2>
<p><i id="p_83" class="pid"></i>The sub-command<a href="#p_83" class="pid">83</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach rpc-run CMD" href="#"></a></div><ol class="snippet"><li value="1">$ reach rpc-run CMD</li></ol></pre>
<p>
  <i id="p_84" class="pid"></i>is a convenient means of launching a pre-configured RPC server and
  frontend which are suitable for development purposes.
  It uses a <code>REACH_RPC_KEY</code> value of <code>opensesame</code> (the standard
  development API key), and sets <code>REACH_RPC_TLS_REJECT_UNVERIFIED</code> to
  <code>0</code>.<a href="#p_84" class="pid">84</a>
</p>
<p><i id="p_85" class="pid"></i>Consider this example from the <a href="/tut/rps/7-rpc/#tut-7-rpc">Rock, Paper, Scissors in Python</a> tutorial:<a href="#p_85" class="pid">85</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach rpc-run python3 -u ./index.py" href="#"></a></div><ol class="snippet"><li value="1">$ reach rpc-run python3 -u ./index.py</li></ol></pre>
<h2 id="ref-usage-docker-reset" class="refHeader"><code>reach docker-reset</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-docker-reset"><span class="icon icon-link"></span></a></h2>
<p><i id="p_86" class="pid"></i>You can easily kill and remove all Docker containers by executing<a href="#p_86" class="pid">86</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach docker-reset" href="#"></a></div><ol class="snippet"><li value="1">$ reach docker-reset</li></ol></pre>
<p>
  <i id="p_87" class="pid"></i>This can be a useful thing to try if your Docker containers stop responding to requests or otherwise misbehave, or if you have updated your Reach images (with <code>reach update</code>) but those changes are not taking effect.
  This command is a loose approximation of "turning Docker off and on again."
  It will affect all Docker containers on your machine, not just those created by Reach.<a href="#p_87" class="pid">87</a>
</p>
<h2 id="ref-usage-upgrade" class="refHeader"><code>reach upgrade</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-upgrade"><span class="icon icon-link"></span></a></h2>
<p><i id="p_88" class="pid"></i>You can upgrade your Reach installation by executing<a href="#p_88" class="pid">88</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach upgrade" href="#"></a></div><ol class="snippet"><li value="1">$ reach upgrade</li></ol></pre>
<p><i id="p_89" class="pid"></i>This may change the default version used by <code>reach</code> commands.<a href="#p_89" class="pid">89</a></p>
<h2 id="ref-usage-update" class="refHeader"><code>reach update</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-update"><span class="icon icon-link"></span></a></h2>
<p><i id="p_90" class="pid"></i>You can update the Docker images used by your Reach installation by executing<a href="#p_90" class="pid">90</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach update" href="#"></a></div><ol class="snippet"><li value="1">$ reach update</li></ol></pre>
<p><i id="p_91" class="pid"></i>This may change the patch version used by <code>reach</code> commands.<a href="#p_91" class="pid">91</a></p>
<h2 id="ref-usage-version" class="refHeader"><code>reach version</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-version"><span class="icon icon-link"></span></a></h2>
<p><i id="p_92" class="pid"></i>You can see what version of Reach you have installed by running<a href="#p_92" class="pid">92</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach version" href="#"></a></div><ol class="snippet"><li value="1">$ reach version</li></ol></pre>
<h2 id="ref-usage-hashes" class="refHeader"><code>reach hashes</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-hashes"><span class="icon icon-link"></span></a></h2>
<p><i id="p_93" class="pid"></i>You can see which exact versions of Reach Docker images you are using by running<a href="#p_93" class="pid">93</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach hashes" href="#"></a></div><ol class="snippet"><li value="1">$ reach hashes</li></ol></pre>
<p>
  <i id="p_94" class="pid"></i>This is more precise, but less readable, than <code>reach version</code>,
  in that each hash refers to the git commit used to build the image.<a href="#p_94" class="pid">94</a>
</p>
<h2 id="ref-usage-config" class="refHeader"><code>reach config</code><a aria-hidden="true" tabindex="-1" href="#ref-usage-config"><span class="icon icon-link"></span></a></h2>
<p><i id="p_95" class="pid"></i>Reach recommends tuning your default workflow settings by executing<a href="#p_95" class="pid">95</a></p>
<pre class="snippet unnumbered"><div class="codeHeader">&nbsp;<a class="far fa-copy copyBtn" data-clipboard-text="$ reach config" href="#"></a></div><ol class="snippet"><li value="1">$ reach config</li></ol></pre>
<p><i id="p_96" class="pid"></i>Using <code>reach config</code> is advisable when running Reach for the first time since it will set the <code>REACH_CONNECTOR_MODE</code> environment variable, which is required when executing some other sub-commands (e.g. <code>reach run</code>).<a href="#p_96" class="pid">96</a></p>
<p>
  <i id="p_97" class="pid"></i><code>reach config</code> presents users with a guided menu which automatically creates an <code>env</code> file and suggests subsequent steps to activate and make it permanent.
  This <code>env</code> file exports environment variable settings and is intended to be <code>source</code>d by users' shells.<a href="#p_97" class="pid">97</a>
</p>
<p><i id="p_98" class="pid"></i>If an <code>env</code> file already exists, <code>reach config</code> will offer to back it up before proceeding.<a href="#p_98" class="pid">98</a></p>