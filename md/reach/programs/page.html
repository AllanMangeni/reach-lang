<p>
  This document describes the structure and content of Reach <span id="term_programs">programs</span>, including
  their syntactic forms,
  the standard library,
  and the standards of valid programs.
</p>
<div class="note">
  <p>Get language support for Reach in your editor by visiting <a href="/md/guide/editor-support/#guide-editor-support">IDE/Text Editor Support</a>.</p>
</div>
<p>The rest of this section is structured according to the contexts of the different parts of a Reach program, as follows:</p>
<ul>
  <li><a href="/md/reach/programs/#ref-programs-valid">Validity and other concepts</a> describes what is meant by the term valid in Reach.</li>
  <li><a href="/md/reach/module/#ref-programs-module">Modules</a> describes the top-level structure of a Reach module.</li>
  <li><a href="/md/reach/appinit/#ref-programs-appinit">Application Initialization</a> describes the structure of Reach application initialization.</li>
  <li><a href="/md/reach/step/#ref-programs-step">Steps</a> describes the structure of Reach steps.</li>
  <li><a href="/md/reach/local/#ref-programs-local">Local Steps</a> describes the structure of Reach local steps.</li>
  <li><a href="/md/reach/consensus/#ref-programs-consensus">Consensus Steps</a> describes the structure of Reach consensus steps.</li>
  <li><a href="/md/reach/compute/#ref-programs-compute">Computations</a> describes the common structure of Reach computations shared by all contexts.</li>
</ul>
<p>The relationship between the modes of a Reach application is shown by this diagram:</p>
<p>
  <img src="/images/reference/StepDiagram.png" alt="">
</p>
<h2 id="ref-programs-valid">Validity and other concepts<a aria-hidden="true" tabindex="-1" href="#ref-programs-valid"><span class="icon icon-link"></span></a></h2>
<p>
  Reach imposes further restrictions on syntactically well-formed programs.
  These restrictions are described throughout this manual using the term <span id="term_valid">valid</span> to refer to constructions that obey the restrictions,
  and the term <span id="term_invalid">invalid</span> to refer to constructions that do not obey them.
</p>
<p>
  It is always invalid to use a value with an operation for which it is undefined.
  For example, <code>1 + true</code> is invalid.
  In other words, Reach enforces a static type discipline.
</p>
<h3 id="security-levels-and-scope">Security levels and scope<a aria-hidden="true" tabindex="-1" href="#security-levels-and-scope"><span class="icon icon-link"></span></a></h3>
<p>
  The text of a Reach program is public knowledge to all participants.
  However, any value that comes from an interaction expression is a <span id="term_secret">secret</span> which only that participant knows.
  Furthermore, any values derived from secret values are also secret.
  A value, X, is considered derived from another, Y, if the value of Y is provided to a primitive operation to arrive at X, or if Y is used as part of a conditional that influences the definition of X.
  Secrets can only be made public by using the declassify primitive.
</p>
<p>
  When secret values are bound to an identifier
  within a local step,
  the identifier name MUST be prefixed by an underscore (<code>_</code>).
</p>
<p>
  When public values are bound to an identifier,
  regardless of context,
  the identifier name MUST NOT be prefixed by an underscore (<code>_</code>).
</p>
<p>
  Consequently, identifiers which appear inside of a
  function definition or arrow expression
  MAY be prefixed by an underscore.
  This will cause a compiler error if any value bound to that
  identifier is public.
</p>
<h3 id="domination">Domination<a aria-hidden="true" tabindex="-1" href="#domination"><span class="icon icon-link"></span></a></h3>
<p>
  A term Y is said to be "<span id="term_dominated">dominated</span>" by a term X if all paths in the control-flow graph of the application from the root to Y pass through X.
  In most cases, this corresponds to "X appears above Y at the same or lower level of indentation" in the program source code.
</p>
<p>For example, in the following program:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"><span style="color: #8250DF">f</span><span style="color: #24292F">();</span></li><li value="2"><span style="color: #CF222E">if</span><span style="color: #24292F"> ( </span><span style="color: #8250DF">p</span><span style="color: #24292F">() ) {</span></li><li value="3"><span style="color: #24292F"> </span><span style="color: #8250DF">g</span><span style="color: #24292F">();</span></li><li value="4"><span style="color: #24292F">} </span><span style="color: #CF222E">else</span><span style="color: #24292F"> {</span></li><li value="5"><span style="color: #24292F"> </span><span style="color: #8250DF">h</span><span style="color: #24292F">();</span></li><li value="6"><span style="color: #24292F">}</span></li><li value="7"><span style="color: #8250DF">m</span><span style="color: #24292F">();</span></li></ol></pre>
<p>
  <code>f</code> dominates <code>p</code>, <code>g</code>, <code>h</code>, and <code>m</code>.
  But no other term dominates any other term.
  In particular, <code>g</code> does not dominate <code>m</code> because it is possible to reach <code>m</code> without going through <code>g</code>, such as when <code>p()</code> is false.
</p>