<p>
  The main sequence of the tutorial uses the
  <a href="##ref-frontends-js">JavaScript frontend support library</a> to implement
  a frontend for our Reach program using JavaScript.
  But, Reach supports using any programming language through the
  <a href="##ref-backends-rpc">Reach RPC Server</a>.
</p>
<p>
  This tutorial walks through using this technique to implement a <em>Rock, Paper, Scissors!</em> frontend
  in Python.
  It is based on the frontend from ["XXX","seclink","tut-7"], so it does not include a
  text-based interface, or a Web interface, but uses the final version of the
  Reach code.
</p>
<p>
  Below we will compare the ["XXX","seclink","tut-7"] JavaScript frontend with the
  equivalent Python code communicating via RPC, section by section.
  Follow along by typing the Python code into a file called <code>index.py</code>.
</p>
<hr>
<p>We begin by comparing the necessary imports and program body:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1">import { loadStdlib } from '@reach-sh/stdlib';</li><li value="2">import * as backend from './build/index.main.mjs';</li><li value="3">const stdlib = loadStdlib(process.env);</li><li value="4"></li><li value="5">(async () =&gt; {</li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import random</li><li value="4">from threading import Thread</li><li value="5">from reach_rpc import mk_rpc</li><li value="6"></li><li value="7"></li><li value="8">def main():</li><li value="9">    rpc, rpc_callbacks = mk_rpc()</li><li value="10"></li></ol></pre>
<p>
  Rather than importing <code>loadStdlib</code> and <code>backend</code> as with the
  JavaScript version, the Python frontend instead plucks <code>mk_rpc</code> from its
  supporting <code>reach_rpc</code> library.
  It is unnecessary for an RPC <em>frontend</em> to import a backend
  because the <a href="##ref-backends-rpc">RPC Server</a> handles doing so instead.
</p>
<p>
  The Python version also borrows functionality from the <code>random</code> and
  <code>threading</code> libraries.
  These will be necessary when providing callable methods in the
  participant interact interface it offers the RPC server.
</p>
<p>
  On line 9 the Python program binds <code>rpc</code> and <code>rpc_callbacks</code> out of
  <code>mk_rpc</code>.
  These two functions are the only tools we will need to communicate with the
  RPC server.
  See ["XXX","seclink","ref-frontends-rpc-py"] for more details on how they work.
</p>
<hr>
<p>
  Next, we define our Alice and Bob accounts and pre-fund them each with a
  starting balance of <code>10</code>.
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="6">  const startingBalance = stdlib.parseCurrency(100);</li><li value="7">  const accAlice = await stdlib.newTestAccount(startingBalance);</li><li value="8">  const accBob = await stdlib.newTestAccount(startingBalance);</li><li value="9"></li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="11">    starting_balance = rpc('/stdlib/parseCurrency', 100)</li><li value="12">    acc_alice        = rpc('/stdlib/newTestAccount', starting_balance)</li><li value="13">    acc_bob          = rpc('/stdlib/newTestAccount', starting_balance)</li><li value="14"></li></ol></pre>
<p>
  Translating code which uses the
  <a href="##ref-frontends-js">JavaScript frontend support library</a> to its
  <a href="##ref-frontends-rpc-py">Python RPC</a> equivalent is a simple matter of
  specifying the corresponding RPC method (e.g.
  <code>'/stdlib/newTestAccount'</code>), and supplying the same arguments thereafter.
</p>
<hr>
<p>
  Now we define two helper functions and use them to query Alice and Bob's
  beginning balances:
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="10">  const fmt = (x) =&gt; stdlib.formatCurrency(x, 4);</li><li value="11">  const getBalance = async (who) =&gt; fmt(await stdlib.balanceOf(who));</li><li value="12">  const beforeAlice = await getBalance(accAlice);</li><li value="13">  const beforeBob = await getBalance(accBob);</li><li value="14"></li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="15">    def fmt(x):</li><li value="16">        return rpc('/stdlib/formatCurrency', x, 4)</li><li value="17"></li><li value="18">    def get_balance(w):</li><li value="19">        return fmt(rpc('/stdlib/balanceOf', w))</li><li value="20"></li><li value="21">    before_alice = get_balance(acc_alice)</li><li value="22">    before_bob   = get_balance(acc_bob)</li><li value="23"></li></ol></pre>
<hr>
<p>Deploying and attaching to contracts works slightly differently over RPC:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="15">  const ctcAlice = accAlice.contract(backend);</li><li value="16">  const ctcBob = accBob.contract(backend, ctcAlice.getInfo());</li><li value="17"></li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="24">    ctc_alice    = rpc('/acc/deploy', acc_alice)</li><li value="25"></li></ol></pre>
<p>
  As previously mentioned, it is the responsibility of the
  <a href="##ref-backends-rpc">RPC Server</a> (rather than that of the frontend
  communicating over RPC) to interface with the DApp's backend, so that
  argument is absent in the Python version shown above.
  Instead, Alice's account RPC handle alone is sufficient for her to
  deploy.
  We also need to delay Bob's attach until later, because Python lacks Promises that work like JavaScript's.
  When we do attach Bob, only Bob's account RPC handle and Alice's
  contract RPC handle are necessary for him to attach.
</p>
<hr>
<p>
  <code>HAND</code> and <code>OUTCOME</code> only differ syntactically from their JavaScript
  equivalents:
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="18">  const HAND = ['Rock', 'Paper', 'Scissors'];</li><li value="19">  const OUTCOME = ['Bob wins', 'Draw', 'Alice wins'];</li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="26">    HAND         = ['Rock', 'Paper', 'Scissors']</li><li value="27">    OUTCOME      = ['Bob wins', 'Draw', 'Alice wins']</li><li value="28"></li></ol></pre>
<hr>
<p>Even participant interact interface definitions remain largely the same:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="20">  const Player = (Who) =&gt; ({</li><li value="21">    ...stdlib.hasRandom,</li><li value="22">    getHand: async () =&gt; { // &lt;-- async now</li><li value="23">      const hand = Math.floor(Math.random() * 3);</li><li value="24">      console.log(`${Who} played ${HAND[hand]}`);</li><li value="25">      if ( Math.random() &lt;= 0.01 ) {</li><li value="26">        for ( let i = 0; i &lt; 10; i++ ) {</li><li value="27">          console.log(`  ${Who} takes their sweet time sending it back...`);</li><li value="28">          await stdlib.wait(1);</li><li value="29">        }</li><li value="30">      }</li><li value="31">      return hand;</li><li value="32">    },</li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="29">    def player(who):</li><li value="30">        def getHand():</li><li value="31">            hand = random.randint(0, 2)</li><li value="32">            print('%s played %s' % (who, HAND[hand]))</li><li value="33">            return hand</li><li value="34"></li></ol></pre>
<p>
  Here, both the JavaScript and Python frontends begin declaring a
  reusable "player constructor".
  This constructor represents those fields which are common to both Alice and
  Bob's participant interact interfaces.
</p>
<p>
  The JavaScript code explicitly includes <code>...stdlib.hasRandom</code> itself, but
  the Python code can instead direct the RPC server to append it to the interface
  by including <code>'stdlib.hasRandom': True</code> as a field in the constructor's
  <a href="#py-return">return value</a>.
</p>
<p>
  Next, they each define a <code>getHand</code> function which randomly selects an
  element from the previously defined <code>HAND</code> set and returns it to the
  backend.
  This function will be passed as a callable method of the interface later.
</p>
<p>
  The Python version does not mimic the JavaScript's occasional "pause behavior",
  although it easily could with a few extra lines of code.
</p>
<hr>
<p>
  <code>informTimeout</code> requires no subsequent backend interaction and is
  accordingly easily to implement in either language:
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="36">    informTimeout: () =&gt; {</li><li value="37">      console.log(`${Who} observed a timeout`);</li><li value="38">    },</li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="35">        def informTimeout():</li><li value="36">            print('%s observed a timeout' % who)</li><li value="37"></li></ol></pre>
<hr>
<p><a name="py-return"></a>The same is true of <code>seeOutcome</code>:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="33">    seeOutcome: (outcome) =&gt; {</li><li value="34">      console.log(`${Who} saw outcome ${OUTCOME[outcome]}`);</li><li value="35">    },</li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="38">        def seeOutcome(n):</li><li value="39">            print('%s saw outcome %s'</li><li value="40">                  % (who, OUTCOME[rpc('/stdlib/bigNumberToNumber', n)]))</li><li value="41"></li><li value="42">        return {'stdlib.hasRandom': True,</li><li value="43">                'getHand':          getHand,</li><li value="44">                'informTimeout':    informTimeout,</li><li value="45">                'seeOutcome':       seeOutcome,</li><li value="46">                }</li><li value="47"></li></ol></pre>
<p>
  At the end of the Python code we return a <code>dict</code> that represents those
  fields which are common to both Alice and Bob's
  participant interact interfaces.
</p>
<p>
  Again, <code>'stdlib.hasRandom': True</code> has special significance when
  communicating via RPC: it instructs the server to append this signature on the
  receiving end.
</p>
<hr>
<p>
  Finally, we proceed to the most interesting part of the program and use the
  code we have built up thus far to actually play a game of <em>Rock, Paper, Scissors!</em>:
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="41">  await Promise.all([</li><li value="42">    ctcAlice.p.Alice({</li><li value="43">      ...Player('Alice'),</li><li value="44">      wager: stdlib.parseCurrency(5),</li><li value="45">      deadline: 10,</li><li value="46">    }),</li><li value="47">    ctcBob.p.Bob({</li><li value="48">      ...Player('Bob'),</li><li value="49">      acceptWager: (amt) =&gt; {</li><li value="50">        console.log(`Bob accepts the wager of ${fmt(amt)}.`);</li><li value="51">      },</li><li value="52">    }),</li><li value="53">  ]);</li><li value="54"></li><li value="55">  const afterAlice = await getBalance(accAlice);</li><li value="56">  const afterBob = await getBalance(accBob);</li><li value="57"></li><li value="58">  console.log(`Alice went from ${beforeAlice} to ${afterAlice}.`);</li><li value="59">  console.log(`Bob went from ${beforeBob} to ${afterBob}.`);</li><li value="60"></li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="48">    def play_alice():</li><li value="49">        rpc_callbacks(</li><li value="50">            '/backend/Alice',</li><li value="51">            ctc_alice,</li><li value="52">            dict(wager=rpc('/stdlib/parseCurrency', 5), deadline=10, **player('Alice')))</li><li value="53"></li><li value="54">    alice = Thread(target=play_alice)</li><li value="55">    alice.start()</li><li value="56"></li><li value="57">    def play_bob():</li><li value="58">        def acceptWager(amt):</li><li value="59">            print('Bob accepts the wager of %s' % fmt(amt))</li><li value="60"></li><li value="61">        ctc_bob = rpc('/acc/attach', acc_bob, rpc('/ctc/getInfo', ctc_alice))</li><li value="62">        rpc_callbacks(</li><li value="63">            '/backend/Bob',</li><li value="64">            ctc_bob,</li><li value="65">            dict(acceptWager=acceptWager, **player('Bob')))</li><li value="66">        rpc('/forget/ctc', ctc_bob)</li><li value="67"></li><li value="68">    bob = Thread(target=play_bob)</li><li value="69">    bob.start()</li><li value="70"></li><li value="71">    alice.join()</li><li value="72">    bob.join()</li><li value="73"></li><li value="74">    after_alice = get_balance(acc_alice)</li><li value="75">    after_bob   = get_balance(acc_bob)</li><li value="76"></li><li value="77">    print('Alice went from %s to %s' % (before_alice, after_alice))</li><li value="78">    print('  Bob went from %s to %s' % (before_bob,   after_bob))</li><li value="79"></li><li value="80">    rpc('/forget/acc', acc_alice, acc_bob)</li><li value="81">    rpc('/forget/ctc', ctc_alice)</li><li value="82"></li><li value="83"></li><li value="84">if __name__ == '__main__':</li><li value="85">    main()</li></ol></pre>
<p>
  In the Python version we create a function called <code>play_alice</code> and spawn
  it as a concurrent thread, which begins running in the background on line 56.
</p>
<p>
  <code>play_alice</code> sends Alice's contract RPC handle and her
  participant interact interface to the server with <code>rpc_callbacks</code>.
  The interface includes methods and values created by <code>player('Alice')</code>,
  and adds an additional <code>wager</code> value which is set to the result of
  <code>rpc('/stdlib/parseCurrency', 5)</code>,
  as well as setting a <code>deadline</code> of <code>10</code>.
</p>
<p>
  Bob's interface is likewise defined and spawned as another thread, which also
  begins running concurrently on line 69.
  In Bob's case we add an <code>acceptWager</code> method instead of another value to
  his participant interact interface.
  Furthermore, his function is more complex, because we delay creating his contract handle until this time, so that the main thread does not block waiting for Alice's contract information to resolve.
  This separation is not necessary in JavaScript, because of how JavaScript Promises work.
</p>
<p>
  Calling <code>.join()</code> on <code>alice</code> and <code>bob</code> instructs the main thread
  to wait until both child threads have run to completion, signifying the end of
  the <em>Rock, Paper, Scissors!</em> game.
  At this point we again collect each player's remaining balance and print them
  to the console.
  Each player's child thread will have already printed their success/failure
  result to the screen prior to reaching this step, because that is how we encoded
  their <code>seeOutcome</code> methods.
</p>
<p>
  All that remains is to release Alice and Bob's RPC handles from the
  server's memory on lines 80 and 81 with the <code>/forget/acc</code> and
  <code>/forget/ctc</code> methods, then instruct the Python process' interpreter to
  invoke our <code>main</code> function.
</p>
<hr>
<p>
  Now that we have written an entire <em>Rock, Paper, Scissors!</em> game in Python it is time to try
  running it.
</p>
<p>
  First you will need to copy the <code>index.rsh</code> file you used for <a href="##tut-7">the tutorial</a>
  into the directory where you saved <code>index.py</code>.
</p>
<p>
  Next, open a terminal in that directory and install the Reach Python RPC
  client:
</p>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1">$ ([ -d ./venv ] || python3 -m venv ./venv) &amp;&amp; source ./venv/bin/activate</li></ol></pre>
<div class="note">
  <p>What is this <code>"venv"</code> thing?</p>
  <p>
    A Python
    <a href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment">venv</a>
    is a "virtual environment" that sandboxes dependencies to avoid cluttering your
    system directories.
  </p>
</div>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1">$ pip install --upgrade reach-rpc-client</li></ol></pre>
<p>Then use <code>./reach rpc-run</code> to play a game of <em>Rock, Paper, Scissors!</em>:</p>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1">$ ./reach rpc-run python3 -u ./index.py</li></ol></pre>
<div class="note">
  <p>
    Consult the <a href="##ref-usage-rpc-run">command-line</a> reference section for more details on
    how this sub-command works.
  </p>
</div>
<p>Its output will be the same as the <a href="##tut-7">final tutorial</a> version of the frontend:</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1">Bob accepts the wager of 5</li><li value="2">Alice played Rock</li><li value="3">Bob played Paper</li><li value="4">Bob saw outcome Bob wins</li><li value="5">Alice saw outcome Bob wins</li><li value="6">Alice went from 10 to 4.9999</li><li value="7">  Bob went from 10 to 14.9999</li></ol></pre>
<p>
  This will launch an RPC server using the development API key
  <code>"opensesame"</code> and a TLS certificate designed for testing.
</p>
<div class="note">
  <p>
    Deploying your DApp into production with the RPC server requires obtaining a
    certificate which is specific to your DNS domain and which has been signed by a
    certificate authority such as
    <a href="https://letsencrypt.org/getting-started/">Let's Encrypt</a>.
  </p>
  <p>
    Users who are ready to go live should consult the <a href="##ref-usage-rpc-server">RPC Server command-line</a>
    reference section for configuration details.
  </p>
</div>
<p>When you are done, type <code>deactivate</code> to exit your <code>venv</code>.</p>
<p>Well done! You have just reimplemented <a href="##tut-7">the tutorial</a> in Python.</p>
<hr>
<p>
  This tutorial uses Python to demonstrate how RPC frontends are
  built in Reach, but it is similarly easy to write RPC frontends in other
  languages, such as with the ["XXX","seclink","ref-frontends-rpc-js"] and
  ["XXX","seclink","ref-frontends-rpc-go"] libraries.
</p>