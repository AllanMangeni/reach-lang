<h1 id="arithmetic-operators">Arithmetic Operators<a aria-hidden="true" tabindex="-1" href="#arithmetic-operators"><span class="icon icon-link"></span></a></h1>
<p>These operators work on unsigned integers. Corresponding functions are <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, and <code>mod</code>.</p>
<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+</code></td>
      <td>Add</td>
      <td><code>const v = 5 + 3; // 8</code></td>
    </tr>
    <tr>
      <td><code>-</code></td>
      <td>Subtract</td>
      <td><code>const v = 5 - 3; // 2</code></td>
    </tr>
    <tr>
      <td><code>*</code></td>
      <td>Multiply</td>
      <td><code>const v = 5 * 3; // 15</code></td>
    </tr>
    <tr>
      <td><code>/</code></td>
      <td>Divide</td>
      <td><code>const v = 5 / 3; // 1</code></td>
    </tr>
    <tr>
      <td><code>%</code></td>
      <td>Modulus</td>
      <td><code>const v = 5 % 3; // 2</code></td>
    </tr>
  </tbody>
</table>
<h1 id="assignment-operators">Assignment Operators<a aria-hidden="true" tabindex="-1" href="#assignment-operators"><span class="icon icon-link"></span></a></h1>
<p>Reach supports only the assignment operator (i.e. <code>=</code>). All other operators (e.g. <code>+=</code>, <code>*=</code>, ...) are invalid because Reach does not support the reassignment of an identifier.</p>
<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>=</code></td>
      <td><code>Assign</code></td>
      <td><code>const v = 5;</code></td>
    </tr>
  </tbody>
</table>
<h1 id="bitwise-operators">Bitwise Operators<a aria-hidden="true" tabindex="-1" href="#bitwise-operators"><span class="icon icon-link"></span></a></h1>
<p>Bitwise operations are not supported by all consensus networks. They also decrease the efficiency of verification.</p>
<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>&amp;</code></td>
      <td><code>AND</code></td>
      <td><code>const v = 15 &amp; 29; // 13</code></td>
    </tr>
    <tr>
      <td><code>|</code></td>
      <td><code>OR</code></td>
      <td><code>const v = 12 | 3; // 15</code></td>
    </tr>
    <tr>
      <td><code>^</code></td>
      <td><code>XOR</code></td>
      <td><code>const v = 15 ^ 13; // 2</code></td>
    </tr>
    <tr>
      <td><code>&lt;&lt;</code></td>
      <td><code>Left Shift</code></td>
      <td><code>const v = 2 &lt;&lt; 3; // 16</code></td>
    </tr>
    <tr>
      <td><code>&gt;&gt;</code></td>
      <td><code>Right Shift</code></td>
      <td><code>const v = 16 &gt;&gt; 3; // 2</code></td>
    </tr>
  </tbody>
</table>
<h1 id="comparison-operators">Comparison Operators<a aria-hidden="true" tabindex="-1" href="#comparison-operators"><span class="icon icon-link"></span></a></h1>
<p>Comparison operators evaluate to <code>true</code> or <code>false</code>. Comparisons between values of different types are invalid. Therefore, <code>==</code> and <code>===</code> have the same meaning, and <code>!=</code> and <code>!==</code> do, too.</p>
<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>==</code><br><code>===</code></td>
      <td><code>is equal to</code></td>
      <td><code>x == y</code><br><code>x === y</code></td>
    </tr>
    <tr>
      <td><code>!=</code><br><code>!==</code></td>
      <td><code>is not equal to</code></td>
      <td><code>x != y</code><br><code>x !== y</code></td>
    </tr>
    <tr>
      <td><code>&gt;</code></td>
      <td><code>is greater than</code></td>
      <td><code>x &gt; y</code></td>
    </tr>
    <tr>
      <td><code>&gt;=</code></td>
      <td><code>is greater than or equal to</code></td>
      <td><code>x &gt;= y</code></td>
    </tr>
    <tr>
      <td><code>&lt;</code></td>
      <td><code>is less than</code></td>
      <td><code>x &lt; y</code></td>
    </tr>
    <tr>
      <td><code>&lt;=</code></td>
      <td><code>is less than or equal to</code></td>
      <td><code>x &lt;= y</code></td>
    </tr>
  </tbody>
</table>
<h1 id="logical-operators">Logical Operators<a aria-hidden="true" tabindex="-1" href="#logical-operators"><span class="icon icon-link"></span></a></h1>
<p>Logical <code>and</code> evaluates to <code>true</code> when both the left-side expression and the right-side expression evaluate to <code>true</code>, and logical <code>or</code> evaluates to <code>true</code> when either the left-side expression or the right-side expression evaluates to <code>true</code>.</p>
<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>&amp;&amp;</code></td>
      <td>and</td>
      <td><code>x &amp;&amp; y</code></td>
    </tr>
    <tr>
      <td><code>||</code></td>
      <td>and</td>
      <td><code>x || y</code></td>
    </tr>
  </tbody>
</table>
<h1 id="type-operator">Type Operator<a aria-hidden="true" tabindex="-1" href="#type-operator"><span class="icon icon-link"></span></a></h1>
<p>Reach supports the <code>typeof</code> operator and two functions, <code>typeOf()</code> and <code>is()</code>, for examining data types of values.</p>
<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>typeof</code></td>
      <td>and</td>
      <td><code>typeof a</code></td>
    </tr>
    <tr>
      <td><code>||</code></td>
      <td>and</td>
      <td><code>x || y</code></td>
    </tr>
  </tbody>
</table>
<p>The <code>typeof</code> operator and the <code>typeOf</code> function return the data type of a value:</p>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1"><span style="color: #CF222E">const</span><span style="color: #24292F"> </span><span style="color: #0550AE">XTy</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> </span><span style="color: #CF222E">typeof</span><span style="color: #24292F"> </span><span style="color: #0550AE">0</span><span style="color: #24292F">;</span></li><li value="2"><span style="color: #CF222E">const</span><span style="color: #24292F"> </span><span style="color: #0550AE">YTy</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> </span><span style="color: #8250DF">typeOf</span><span style="color: #24292F">(</span><span style="color: #0550AE">true</span><span style="color: #24292F">);</span></li></ol></pre>
<p>You can use the returned type in declarations like this:</p>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1"><span style="color: #CF222E">const</span><span style="color: #24292F"> </span><span style="color: #0550AE">myInteract</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> {</span></li><li value="2"><span style="color: #24292F">  getX: </span><span style="color: #8250DF">Fun</span><span style="color: #24292F">([], XTy),</span></li><li value="3"><span style="color: #24292F">  getY: </span><span style="color: #8250DF">Fun</span><span style="color: #24292F">([], YTy)</span></li><li value="4"><span style="color: #24292F">}</span></li></ol></pre>
<p>The <code>is</code> function verifies that a variable is of a certain type:</p>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1"><span style="color: #CF222E">const</span><span style="color: #24292F"> </span><span style="color: #8250DF">addOneImpl</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> (</span><span style="color: #953800">x</span><span style="color: #24292F">) </span><span style="color: #CF222E">=&gt;</span><span style="color: #24292F"> x </span><span style="color: #CF222E">+</span><span style="color: #24292F"> </span><span style="color: #0550AE">1</span><span style="color: #24292F">;</span></li><li value="2"><span style="color: #CF222E">export</span><span style="color: #24292F"> </span><span style="color: #CF222E">const</span><span style="color: #24292F"> </span><span style="color: #0550AE">addOne</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> </span><span style="color: #8250DF">is</span><span style="color: #24292F">(addOneImpl, </span><span style="color: #8250DF">Fun</span><span style="color: #24292F">([UInt], UInt));</span></li></ol></pre>
<p>Because <code>addOneImpl</code> is of type <code>Fun([UInt], UInt)</code>, <code>is()</code> returns <code>addOneImpl</code>. On the other hand, consider this:</p>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1"><span style="color: #CF222E">const</span><span style="color: #24292F"> </span><span style="color: #8250DF">addOneImpl</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> (</span><span style="color: #953800">x</span><span style="color: #24292F">) </span><span style="color: #CF222E">=&gt;</span><span style="color: #24292F"> x </span><span style="color: #CF222E">+</span><span style="color: #24292F"> </span><span style="color: #0550AE">1</span><span style="color: #24292F">;</span></li><li value="2"><span style="color: #CF222E">export</span><span style="color: #24292F"> </span><span style="color: #CF222E">const</span><span style="color: #24292F"> </span><span style="color: #0550AE">addOne</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> </span><span style="color: #8250DF">is</span><span style="color: #24292F">(addOneImpl, </span><span style="color: #8250DF">Fun</span><span style="color: #24292F">([UInt], Null)); </span><span style="color: #6E7781">// invalid</span></li></ol></pre>
<p>Because <code>addOneImpl</code> is not of type <code>Fun([UInt], Null)</code>, the compiler outputs an error:</p>
<pre class="snippet unnumbered"><ol class="snippet"><li value="1">These types are mismatched: UInt vs Null</li></ol></pre>
<h1 id="ternary-operator">Ternary Operator<a aria-hidden="true" tabindex="-1" href="#ternary-operator"><span class="icon icon-link"></span></a></h1>
<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Name</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>? :</code></td>
      <td>and</td>
      <td><code>a == b ? c : d</code></td>
    </tr>
  </tbody>
</table>