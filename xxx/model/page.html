<p>This document describes the fundamental assumptions and concepts of Reach. First, we discuss the model of running a Reach program in <a href="/xxx/model/#ref-model-eval">Evaluation Model</a>. Next, we discuss the details about compilation of a Reach program that are relevant to Reach programmers in <a href="/xxx/model/#ref-model-compile">Compilation Model</a>. Finally, we discuss how Reach programs are syntactically constructed in <a href="/xxx/model/#ref-model-syntax">Syntax Model</a>.</p>
<div class="note">
  <p>
    This is not an introduction to Reach.
    We recommend reading <a href="/xxx/tut/overview/#overview">the overview</a> for an introduction to what Reach is and the <a href="/xxx/tut/rps/#tut">tutorial</a> to get started with programming Reach.
  </p>
  <p>
    Furthermore, it is not an introduction to consensus networks or "blockchain".
    If you would like to read such an introduction, we recommend the <a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">Wikipedia article on consensus</a> and the <a href="https://en.wikipedia.org/wiki/Blockchain">Wikipedia article on blockchains</a>.
  </p>
</div>
<h2 id="ref-model-eval" class="refHeader">Evaluation Model<a aria-hidden="true" tabindex="-1" href="#ref-model-eval"><span class="icon icon-link"></span></a></h2>
<p>Reach programs specify a decentralized application (<span id="term_DApp">DApp</span>), which is a distributed computation involving many participants and utilizing one contract on one consensus network for reaching agreement on the intermediate values of the computation.</p>
<div class="note">
  <p>"Many" is a technical term that means "zero or more".</p>
</div>
<p>When the computation terminates, all participants agree on the outcome, because they agreed on the intermediate values.</p>
<p>At the start of a Reach computation, the set of participants is not necessarily known and can evolve throughout the execution of the application.</p>
<p>
  A <span id="term_consensus%20network">consensus network</span> is a network protocol with a network token, a set of non-network tokens, a set of accounts, a set of contracts, and a network time.
  A <span id="term_network%20token">network token</span> is an opaque unit of account.
  A <span id="term_non-network%20token">non-network token</span> is an opaque unit of account;
  typical consensus networks allow the set of non-network tokens to grow over time and be issued by accounts.
  A consensus network's <span id="term_network%20time">network time</span> is some monotonically increasing discrete value from a totally ordered set; typically, it is the height of the blockchain for consensus networks that use blockchains.
  A <span id="term_time%20delta">time delta</span> represents the difference between two points in network time as a discrete number of network time units.
  Each network time corresponds to some <span id="term_network%20second">network second</span>, which has a connection to real time; typically, it is a <a href="https://en.wikipedia.org/wiki/Unix_time">Unix time</a>.
  Consensus networks support <span id="term_transfers">transfers</span> of network tokens and non-network tokens between accounts.
  An <span id="term_account">account</span> is a unique identity (called an <span id="term_address">address</span>) with a non-negative balance of network tokens.
  Accounts may sign values in a way that may not be repudiated or impersonated; this is called <span id="term_publication">publication</span>.
  The chapter, <a href="/xxx/networks/#ref-networks">Consensus Network Connectors</a>, discusses which consensus networks are supported by Reach.
</p>
<div class="note">
  <p>This description of consensus networks is an abstraction that may not be directly implemented by actual networks.</p>
  <p>
    For example, in UTXO-based networks, there is not typically an explicitly represented account balance ledger.
    However, such networks do <em>abstractly</em> have accounts with balances, because particular private keys represent accounts which have exclusive access to some set of network tokens which is their balance.
  </p>
  <p>
    Similarly, Reach's notion of time may appear overly abstract ("monotonically increasing ... totally ordered set") if you know that many consensus networks are based on blockchains and use the chain length, also called the height or block number, as a notion of time.
    In this case, network time would be a natural number, which is a prototypical model of a totally ordered set.
    However, Reach is flexible enough to support non-blockchain-based consensus networks, so it does not mandate this particular natural number-based notion of time.
  </p>
  <p>
    Finally, Reach's definition of consensus network does not require any particular technology or features of this.
    In particular, it does not only refer to so-called "layer-1" protocols, nor does it exclude centralized systems with trusted parties controlling the network.
  </p>
</div>
<div class="note">
  <p>Reach assumes that network tokens and non-network tokens behave identically, but often they do not; <a href="/xxx/guide/nntoks/#guide-nntoks">this article</a> discusses the causes and consequences of this.</p>
</div>
<p>
  <span id="term_Contracts">Contracts</span> are accounts with three extra capacities: they persistently store values (called the <span id="term_consensus%20state">consensus state</span>), they may receive publications, and when they receive publications, they systematically process them and may modify their consensus state, make publications, and may transfer network tokens and non-network tokens in response to the reception.
  In addition to values, consensus state may contain a fixed number of <span id="term_mappings">mappings</span> between an address and a value.
  These mappings are referred to as "<span id="term_linear%20state">linear state</span>" because their size is linear in the number of participants in the contract.
  Furthermore, a contract may provide <span id="term_views">views</span> of its consensus state, which are labeled functions and values which may be hierarchically organized, such as <code>NFT.owner</code> or <code>scoreOfPlayer</code>.
  These views are visible in sub-trees of the computation graph.
  A contract may also emit <span id="term_event">event</span>s, which are externally observable values that are persistently available.
  The creation of a contract is called <span id="term_deploy">deploy</span>ment.
</p>
<p>
  A <span id="term_participant">participant</span> is a logical actor which takes part in a DApp.
  It is associated with an account on the consensus network.
</p>
<div class="note">
  <p>The same account may be used by multiple participants in a DApp.</p>
</div>
<p>A participant has persistently stored values, called its <span id="term_local%20state">local state</span>. It has a frontend which it interacts with. A <span id="term_frontend">frontend</span> is an abstract actor which supports a set of functions which consume and produce values; when a participant invokes one of these functions it is referred to as <span id="term_interact">interact</span>ion.</p>
<p>
  A <span id="term_participant%20class">participant class</span> is a category of participant that may occur many times in a single application.
  Members of a participant class are referred to as <span id="term_participant%20instances">participant instances</span> when their status as a member of a class is important, but just "participants" otherwise.
  Participant instances are independent participants like any other; for example, with their own local state, frontend, and so on.
  The main distinction is that when a member of a participant class joins an application, it is not fixed like other participants, because a participant instance does not exclusively represent the participant class.
</p>
<p>
  An <span id="term_API">API</span> is a source of publications that do not correspond to any participant and are therefore like asynchronous events that impinge on the computation.
  The contract returns a value to an API call.
  APIs are organized into a labeled hierarchy, like <code>Contest.vote</code> and <code>User.write</code>.
</p>
<p>
  Since DApps have an associated contract, they have an associated account. :::note
  The contract account must be distinct from all participant accounts.
  :::
  This account is assumed to be empty when the computation starts.:::note
  On some consensus networks, it is possible for transfers to a contract account to occur outside of the purview of Reach. If this occurs, then those network tokens are remitted to the originator of the final consensus transfer.
  :::
  Any network tokens transferred into the account must be removed by the DApp's completion. This is called the <span id="term_token%20linearity%20property">token linearity property</span>.
</p>
<p>A DApp computation can be seen as a graph of steps with a unique first step. A <span id="term_step">step</span> is a set of local steps by participants followed by a single consensus step introduced via a single consensus transfer.</p>
<p>A <span id="term_local%20step">local step</span> is executed by a single participant and is a sequence of local computations. A <span id="term_local%20computation">local computation</span> may bind a piece of local state, assert a property of the local state, or interact with the frontend. A <span id="term_consensus%20transfer">consensus transfer</span> is executed by a single participant (called the <span id="term_originator">originator</span>) which makes a publication of a set of public values from its local state and transfers zero or more network tokens to the contract account. A consensus transfer specifies an alternative step, called a <span id="term_timeout">timeout</span>, that is executed if the originator fails to make the transfer before a given time delta has elapsed. All local state is initially <span id="term_private">private</span>, until it is explicitly made <span id="term_public">public</span> via a <span id="term_declassification">declassification</span>, which is a kind of local computation.</p>
<p>
  A participant is said to <span id="term_join">join</span> an application when it first makes a publication.
  For non-participant instances, this also makes the participant <span id="term_fixed">fixed</span>, whereby the consensus state includes an assignment from the participant to the particular account (i.e. address) which it is fixed to.
  All subsequent publications by a fixed participant must be from the fixed account.
</p>
<p>
  A <span id="term_consensus%20step">consensus step</span> is a graph of consensus computations with a unique first computation.
  A <span id="term_consensus%20computation">consensus computation</span> either binds consensus state,
  asserts a property of the consensus state,
  performs a transfer,
  selects between different next consensus computations,
  communicates with another contract (referred to as a remote object),
  or <span id="term_commits">commits</span> to the next step.
</p>
<p>
  An <span id="term_assert">assert</span>ion is either: a <span id="term_knowledge%20assertion">knowledge assertion</span>, which is a claim that one honest participant cannot know something that another honest participant does know; a <span id="term_static%20assertion">static assertion</span>, which is an always-true formula; an <span id="term_assumption">assumption</span>, which is a true formula if frontends behave honestly; a <span id="term_requirement">requirement</span>, which is a true formula if participants behave honestly; or, a <span id="term_possibility%20assertion">possibility assertion</span>, which is a formula for which there exists some values that honest participants and frontends could submit which results in the truth of the formula.
  An <span id="term_honest">honest</span> participant is one that executes the steps specified by the DApp, while an honest frontend is one that only returns values which ensure that all assumptions evaluate to the boolean <code>true</code>.
</p>
<p>
  A <span id="term_value">value</span> is either: the <code>null</code> value, a boolean, an unsigned integer, a string of bytes, a digest, an address, a fixed tuple of values, a statically-sized homogeneous array of values, or a fixed record of values.
  Values may be <span id="term_digest">digest</span>ed to produce a <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash</a> of their binary encoding.
</p>
<p>
  Values are in one of three possible conditions.
  They could be consensus state, in which case they are known to all participants.
  They could be local state of a single participant, which means they are known by only that participant.
  Local state is further divided into private local state, which cannot be included in a publication, and public local state, which can.
  These conditions are summarized thus:
</p>
<ul>
  <li><strong>Local, private</strong>: The initial state.</li>
  <li><strong>Local, public</strong>: The result of <code>declassify</code>.</li>
  <li><strong>Consensus</strong>: The result of <code>publish</code>.</li>
</ul>
<h2 id="ref-model-compile" class="refHeader">Compilation Model<a aria-hidden="true" tabindex="-1" href="#ref-model-compile"><span class="icon icon-link"></span></a></h2>
<p>
  Reach programs cannot execute independently of a consensus network and a set of frontends.
  Thus, the semantics of Reach treats these components abstractly and does not specify their semantics.
  Therefore, the semantics of Reach cannot be effectively implemented directly in a virtual machine or interpreter.
  Instead, Reach programs are <span id="term_compile">compile</span>d to
  a particular consensus network <span id="term_connector">connector</span>
  and a set of participant <span id="term_backends">backends</span>
  which execute the computation of the particular consensus network.
  Connectors and backends are sound
  if they faithfully model the abstract semantics assumed by Reach.
</p>
<p>
  During compilation, the Reach compiler automatically verifies that the token linearity property and all static assertions and possibility assertions are true whether participants and frontends are honest or not.
  Similarly, all knowledge assertions are verified using a conservative approximation of participant knowledge.
  This conservative approximation assumes that all inputs to a computation are revealed by the result of the computation, except for digests and interaction.
  This approximation means that Reach cannot, for example, reason about the details of manually expressed encryption formulas and will assume they are insecure.
  Finally, a subtle point about the knowledge checker is relevant: technically participants with different identities in a Reach program may actually be instantiated by the same principals, i.e. if Alice choses to play a game of a Chess against herself, where she controls both Black and White; as this is always possible, the knowledge checker does not consider it a violation of a claim that White knows something Black does not.
</p>
<p>
  If these assertions cannot be statically verified, then the compilation process aborts.
  After this verification, such static assertions and possibility assertions are removed from the program and do not occur at runtime.
  In contrast, assumptions are enforced at runtime by backends and requirements are enforced at runtime by connectors.
  If assumptions are violated at runtime, then the backend aborts.
  If requirements are violated at runtime, then the connector ensures that all aspects of the DApp (the contract and participant) ignore the inducing consensus transfer, which often results in a timeout.
</p>
<h2 id="ref-model-syntax" class="refHeader">Syntax Model<a aria-hidden="true" tabindex="-1" href="#ref-model-syntax"><span class="icon icon-link"></span></a></h2>
<p>Reach programs are specified via a subset of well-formed JavaScript syntax inside source files. The section <a href="/xxx/reach/programs/#ref-programs">Programs</a> describes the syntax of Reach programs in detail.</p>